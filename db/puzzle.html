<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Restricted Chess Puzzle</title>
    <link rel="stylesheet" href="puzzle.css">
</head>
<body>
    <h1>Restricted Chess Board Puzzle</h1>
    <div class="container">
        <div class="boards-container">
            <div class="board-wrapper">
                <div class="board-label">Current Position</div>
                <div class="board" id="play-board">
                    <!-- Board cells will be generated by JavaScript -->
                </div>
            </div>
            <div class="board-wrapper">
                <div class="board-label">Target Position</div>
                <div class="board" id="target-board">
                    <!-- Board cells will be generated by JavaScript -->
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button id="reset-btn">Reset</button>
            <button id="undo-btn">Undo Move</button>
        </div>
        
        <div class="moves-counter">Moves: <span id="moves-count">0</span></div>
        
        <div class="success-message" id="success-message">
            Congratulations! You've reached the target position!
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Define the valid positions in our restricted chess board
            const validPositions = [
                [0, 0], [0, 1], 
                [1, 0], [1, 1], [1, 2],
                [2, 0], [2, 1], [2, 2], [2, 3],
                [3, 0], [3, 2]
            ];
            
            // Define the initial configuration
            const initialConfig = [
                {row: 0, col: 0, type: 'white'},  // White knight at top left
                {row: 2, col: 1, type: 'white'},  // White knight in middle
                {row: 3, col: 0, type: 'black'},  // Black knight at bottom left
                {row: 3, col: 2, type: 'black'},  // Black knight at bottom right
            ];
            
            // Define the target configuration
            const targetConfig = [
                {row: 0, col: 0, type: 'black'},  // Black knight at top left
                {row: 2, col: 1, type: 'black'},  // Black knight in middle
                {row: 3, col: 0, type: 'white'},  // White knight at bottom left
                {row: 3, col: 1, type: 'white'},  // White knight at bottom right
            ];
            
            // Game state
            const gameState = {
                currentConfig: JSON.parse(JSON.stringify(initialConfig)),
                moveHistory: [],
                moves: 0,
                selectedCell: null,
            };
            
            // Initialize the play board
            const playBoard = document.getElementById('play-board');
            const targetBoard = document.getElementById('target-board');
            
            // Function to check if a position is valid
            function isValidPosition(row, col) {
                return validPositions.some(pos => pos[0] === row && pos[1] === col);
            }
            
            // Function to create the chess boards
            function createBoard(boardElement, config, isPlayable = false) {
                boardElement.innerHTML = '';
                
                // Create a 4x4 grid
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        
                        // Check if this is a valid position in our restricted board
                        if (!isValidPosition(row, col)) {
                            cell.classList.add('hidden');
                        } else {
                            // Add data attributes for row and column
                            cell.dataset.row = row;
                            cell.dataset.col = col;
                            
                            // Check if there's a knight at this position
                            const knight = config.find(k => k.row === row && k.col === col);
                            if (knight) {
                                cell.innerHTML = 'â™ž';
                                cell.classList.add(knight.type === 'white' ? 'knight-white' : 'knight-black');
                            }
                            
                            // Add click event for playable board
                            if (isPlayable) {
                                cell.addEventListener('click', handleCellClick);
                            }
                        }
                        
                        boardElement.appendChild(cell);
                    }
                }
            }
            
            // Cell click handler
            function handleCellClick(event) {
                const cell = event.currentTarget;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // If no cell is selected and this cell has a knight, select it
                if (gameState.selectedCell === null) {
                    const knight = gameState.currentConfig.find(k => k.row === row && k.col === col);
                    if (knight) {
                        gameState.selectedCell = { row, col, knight };
                        cell.classList.add('selected');
                    }
                } 
                // If a cell is already selected, try to move the knight
                else {
                    const { row: fromRow, col: fromCol, knight } = gameState.selectedCell;
                    
                    // Check if the target cell is empty
                    const isTargetEmpty = !gameState.currentConfig.some(k => k.row === row && k.col === col);
                    
                    if (isTargetEmpty) {
                        // Move the knight
                        moveKnight(fromRow, fromCol, row, col);
                        
                        // Deselect the cell
                        const cells = playBoard.querySelectorAll('.cell');
                        cells.forEach(c => c.classList.remove('selected'));
                        gameState.selectedCell = null;
                    } else {
                        // If clicking on another knight, switch selection
                        const newKnight = gameState.currentConfig.find(k => k.row === row && k.col === col);
                        if (newKnight) {
                            // Deselect the previous cell
                            const cells = playBoard.querySelectorAll('.cell');
                            cells.forEach(c => c.classList.remove('selected'));
                            
                            // Select the new cell
                            gameState.selectedCell = { row, col, knight: newKnight };
                            cell.classList.add('selected');
                        }
                    }
                }
            }
            
            // Function to move a knight
            function moveKnight(fromRow, fromCol, toRow, toCol) {
                // Find the knight to move
                const knightIndex = gameState.currentConfig.findIndex(
                    k => k.row === fromRow && k.col === fromCol
                );
                
                if (knightIndex !== -1) {
                    // Save the current state in history
                    gameState.moveHistory.push(JSON.parse(JSON.stringify(gameState.currentConfig)));
                    
                    // Update the knight's position
                    gameState.currentConfig[knightIndex].row = toRow;
                    gameState.currentConfig[knightIndex].col = toCol;
                    
                    // Increment the move counter
                    gameState.moves++;
                    document.getElementById('moves-count').textContent = gameState.moves;
                    
                    // Redraw the board
                    createBoard(playBoard, gameState.currentConfig, true);
                    
                    // Check if the puzzle is solved
                    checkForWin();
                }
            }
            
            // Function to check if the current configuration matches the target
            function checkForWin() {
                // Sort both configurations to ensure the comparison works regardless of array order
                const sortedCurrent = [...gameState.currentConfig].sort((a, b) => {
                    if (a.row !== b.row) return a.row - b.row;
                    if (a.col !== b.col) return a.col - b.col;
                    return a.type === 'white' ? -1 : 1;
                });
                
                const sortedTarget = [...targetConfig].sort((a, b) => {
                    if (a.row !== b.row) return a.row - b.row;
                    if (a.col !== b.col) return a.col - b.col;
                    return a.type === 'white' ? -1 : 1;
                });
                
                // Check if configurations match
                const matches = sortedCurrent.every((knight, index) => {
                    const targetKnight = sortedTarget[index];
                    return knight.row === targetKnight.row && 
                           knight.col === targetKnight.col && 
                           knight.type === targetKnight.type;
                });
                
                if (matches) {
                    document.getElementById('success-message').style.display = 'block';
                }
            }
            
            // Reset button handler
            document.getElementById('reset-btn').addEventListener('click', () => {
                gameState.currentConfig = JSON.parse(JSON.stringify(initialConfig));
                gameState.moveHistory = [];
                gameState.moves = 0;
                gameState.selectedCell = null;
                
                document.getElementById('moves-count').textContent = '0';
                document.getElementById('success-message').style.display = 'none';
                
                createBoard(playBoard, gameState.currentConfig, true);
            });
            
            // Undo button handler
            document.getElementById('undo-btn').addEventListener('click', () => {
                if (gameState.moveHistory.length > 0) {
                    gameState.currentConfig = gameState.moveHistory.pop();
                    gameState.moves = Math.max(0, gameState.moves - 1);
                    gameState.selectedCell = null;
                    
                    document.getElementById('moves-count').textContent = gameState.moves;
                    document.getElementById('success-message').style.display = 'none';
                    
                    createBoard(playBoard, gameState.currentConfig, true);
                }
            });
            
            // Initialize the boards
            createBoard(playBoard, initialConfig, true);
            createBoard(targetBoard, targetConfig, false);
        });
    </script>
</body>
</html>